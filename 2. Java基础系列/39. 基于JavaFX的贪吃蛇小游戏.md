## æ¸¸æˆèƒŒæ™¯ä»‹ç»

è´ªåƒè›‡æ¸¸æˆæ˜¯ä¸€æ¬¾ç»å…¸çš„å°æ¸¸æˆï¼Œå®ƒçš„ç©æ³•å¾ˆç®€å•ï¼Œå°±æ˜¯æ§åˆ¶è›‡åƒé£Ÿç‰©ï¼Œæ¯åƒä¸€ä¸ªé£Ÿç‰©è›‡çš„é•¿åº¦å°±ä¼šåŠ ä¸€ï¼Œç›´åˆ°è›‡æ’åˆ°å¢™å£æˆ–è€…æ’åˆ°è‡ªå·±æ—¶æ¸¸æˆç»“æŸï¼Œæœ€ç»ˆçš„å¾—åˆ†æ˜¯è›‡çš„é•¿åº¦å‡ä¸€ã€‚


![](https://files.mdnice.com/user/33663/988c51b1-2820-4126-9a7c-09849f10edeb.gif)

## JavaFX

ç”¨Javaå¼€å‘æ¡Œé¢ç«¯é¦–é€‰å°±æ˜¯JavaFXï¼Œå®ƒçš„æ¨å‡ºç”¨æ¥å–ä»£Swingï¼ˆä¸€ä¸ªå¤è€çš„Javaæ¡Œé¢ç«¯æ¡†æ¶ï¼‰ã€‚

è™½ç„¶éƒ½è¯´Javaå¼€å‘æ¡Œé¢ç«¯æ€§èƒ½ä¸è¡Œï¼Œä½†æ˜¯æˆ‘ä»¬çš„Javaå¼€å‘å·¥å…·IntelliJ IDEAçš„ç•Œé¢æ˜¯ç”±JavaFXæ„å»ºçš„ã€‚æœ€å¼€å§‹çš„æˆ‘çš„ä¸–ç•Œï¼ˆMinecraftï¼‰è¿™æ¬¾æ¸¸æˆæ˜¯Javaå¼€å‘çš„ï¼Œè™½ç„¶æ²¡æœ‰ä½¿ç”¨Javaæ ‡å‡†GUIåº“ï¼ˆå®ƒè‡ªå·±çš„æ¸¸æˆå¼•æ“å’Œè‡ªå®šä¹‰çš„ç”¨æˆ·ç•Œé¢ï¼‰ï¼Œä½†ä¹Ÿè¶³ä»¥è¯æ˜Javaçš„é­…åŠ›ã€‚

## æ¸¸æˆè§„åˆ™

* åˆå§‹æ—¶ï¼Œè›‡çš„é•¿åº¦ä¸ºä¸€ï¼Œä½äºæ¸¸æˆç•Œé¢çš„ä¸­å¿ƒä½ç½®ã€‚
* æ¯æ¬¡éšæœºç”Ÿæˆä¸€å—é£Ÿç‰©ï¼Œé£Ÿç‰©ä¸èƒ½å‡ºç°åœ¨è›‡çš„èº«ä½“ä¸Šã€‚
* è›‡å¯ä»¥é€šè¿‡å››ä¸ªæ–¹å‘é”®ä¸Šä¸‹å·¦å³ç§»åŠ¨ï¼Œä¸èƒ½æ’åˆ°å¢™å£æˆ–è‡ªå·±çš„èº«ä½“ã€‚
* æ¯åƒä¸€å—é£Ÿç‰©ï¼Œè›‡çš„é•¿åº¦åŠ ä¸€ã€‚
* ç©¿è¿‡å·¦è¾¹çš„å¢™å£ï¼Œå‡ºç°åœ¨å³è¾¹ï¼›ç©¿è¿‡ä¸Šè¾¹çš„å¢™å£ï¼Œå‡ºç°åœ¨ä¸‹é¢ï¼›åä¹‹äº¦ç„¶ã€‚
* æ¸¸æˆç»“æŸæ—¶ï¼Œå¼¹å‡ºå¾—åˆ†å¯¹è¯æ¡†ï¼Œç‚¹å‡»é‡æ–°å¼€å§‹æ–°æ¸¸æˆã€‚

## ä»£ç ç»“æ„

æœ¬æ•™ç¨‹ä¸»è¦æ¶‰åŠçš„ä»£ç æ–‡ä»¶æ˜¯`SnakeGame.java`ï¼Œæ•´ä¸ªä»£ç æ–‡ä»¶çš„æ¡†æ¶å¦‚ä¸‹ï¼š

```java
import java.util.ArrayDeque;
import java.util.Deque;
import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class SnakeGame extends Application {

    // æ¸¸æˆç•Œé¢çš„å®½åº¦
    private static final int WIDTH = 20;

    // æ¸¸æˆç•Œé¢çš„é«˜åº¦
    private static final int HEIGHT = 20;

    // æ¯ä¸ªæ ¼å­çš„å¤§å°
    private static final int SIZE = 20;

    // è›‡çš„é€Ÿåº¦
    private static final int SPEED = 5;

    // è›‡çš„èº«ä½“
    private Deque<Point> snake = new ArrayDeque<>();

    // è›‡çš„åˆå§‹æ–¹å‘
    private Direction direction = Direction.RIGHT;

    // é£Ÿç‰©çš„ä½ç½®
    private Point food;

    // æ¸¸æˆæ˜¯å¦ç»“æŸ
    private boolean gameOver = false;

    // æ¸¸æˆæ˜¯å¦æš‚åœ
    private boolean gamePaused = false;

    @Override
    public void start(Stage primaryStage) throws Exception {
        // ç•Œé¢åˆå§‹åŒ–
        // ...

        // åˆå§‹åŒ–æ¸¸æˆ
        // ...

        // åŠ¨ç”»å¾ªç¯
        // ...
    }

    // ç•Œé¢åˆå§‹åŒ–æ–¹æ³•
    private void initGUI() {
        // ...
    }

    // åˆå§‹åŒ–æ¸¸æˆæ–¹æ³•
    private void initGame() {
        // ...
    }

    // è›‡çš„ç§»åŠ¨æ–¹æ³•
    private void move() {
        // ...
    }

    // æ£€æµ‹ç¢°æ’æ–¹æ³•
    private void checkCollision() {
        // ...
    }

    // ç”Ÿæˆé£Ÿç‰©æ–¹æ³•
    private void generateFood() {
        // ...
    }

    // ç»˜åˆ¶æ¸¸æˆç”»é¢æ–¹æ³•
    private void paint(GraphicsContext gc) {
        // ...
    }

    // æ˜¾ç¤ºæ¸¸æˆç»“æŸå¯¹è¯æ¡†æ–¹æ³•
    private void showGameOverDialog() {
        // ...
    }

    // æ–¹å‘æšä¸¾ç±»
    private enum Direction {
        UP, DOWN, LEFT, RIGHT
    }

    // åæ ‡ç‚¹ç±»
    private static class Point {
        private int x;
        private int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        @Override
        public boolean equals(Object o) {
            // ...
        }

        @Override
        public int hashCode() {
            // ...
        }
    }

    public static void main(String[] args) {
        launch(args);
    }

}
```

## é€»è¾‘åˆ†æ

åœ¨å®ç°è´ªåƒè›‡æ¸¸æˆä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹æ¸¸æˆçš„é€»è¾‘ã€‚

* åœ¨æ¸¸æˆç•Œé¢å†…ï¼Œä¸æ–­åœ°ç§»åŠ¨è›‡çš„ä½ç½®ã€‚
* è›‡çš„ç§»åŠ¨æ–¹å‘å¯ä»¥é€šè¿‡é”®ç›˜ä¸Šçš„ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘é”®æ¥æ§åˆ¶ã€‚
* å½“è›‡å¤´ç¢°åˆ°è¾¹ç•Œæˆ–ç¢°åˆ°è‡ªå·±çš„èº«ä½“æ—¶ï¼Œæ¸¸æˆç»“æŸã€‚
* å½“è›‡å¤´ç¢°åˆ°é£Ÿç‰©æ—¶ï¼Œå°±ä¼šåƒæ‰é£Ÿç‰©ï¼Œé•¿åº¦åŠ 1ï¼Œéšåç»§ç»­å‘å‰ç§»åŠ¨ã€‚
* åƒæ‰é£Ÿç‰©åï¼Œä¼šé‡æ–°ç”Ÿæˆä¸€ä¸ªæ–°çš„é£Ÿç‰©ï¼Œåˆ¤æ–­æ–°é£Ÿç‰©çš„ä½ç½®æ˜¯å¦å’Œå·²æœ‰çš„è›‡çš„ä½ç½®å†²çªã€‚

## å®ç°æ­¥éª¤

ä¸‹é¢åˆ†æ­¥éª¤è¿›è¡Œå®ç°ï¼Œæ¯ä¸€ä¸ªæ­¥éª¤éƒ½ç»“åˆä»£ç ï¼Œé€»è¾‘æ¸…æ™°ã€‚

#### æ­¥éª¤1ï¼šç•Œé¢åˆå§‹åŒ–

åœ¨`start`æ–¹æ³•ä¸­è¿›è¡Œç•Œé¢çš„åˆå§‹åŒ–ï¼ŒåŒ…æ‹¬åˆ›å»º`Canvas`ã€`GraphicsContext`ç­‰ï¼Œå¹¶å°†`Canvas`æ·»åŠ åˆ°`StackPane`ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œæœ€åæ˜¾ç¤ºèˆå°ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
@Override
public void start(Stage primaryStage) throws Exception {
    // åˆ›å»ºCanvas
    Canvas canvas = new Canvas(WIDTH * SIZE, HEIGHT * SIZE);
    GraphicsContext gc = canvas.getGraphicsContext2D();

    // åˆ›å»ºæ ¹èŠ‚ç‚¹
    StackPane root = new StackPane(canvas);
    root.setAlignment(Pos.CENTER);

    // åˆ›å»ºåœºæ™¯
    Scene scene = new Scene(root);
    scene.setOnKeyPressed(event -> {
        KeyCode keyCode = event.getCode();
        switch (keyCode) {
            // ...
        }
    });

    // æ˜¾ç¤ºèˆå°
    primaryStage.setScene(scene);
    primaryStage.setTitle("è´ªåƒè›‡æ¸¸æˆ");
    primaryStage.setResizable(false);
    primaryStage.show();
}
```

#### æ­¥éª¤2ï¼šåˆå§‹åŒ–æ¸¸æˆ

åœ¨æ¸¸æˆå¼€å§‹å‰ï¼Œéœ€è¦åˆå§‹åŒ–ä¸€äº›å‚æ•°ï¼ŒåŒ…æ‹¬è›‡çš„ä½ç½®ã€é£Ÿç‰©ä½ç½®ã€æ¸¸æˆçŠ¶æ€ç­‰ã€‚å…·ä½“å®ç°ä»£ç å¦‚ä¸‹ï¼š

```java
// åˆå§‹åŒ–æ¸¸æˆæ–¹æ³•
private void initGame() {
    // æ¸…ç©ºè›‡çš„èº«ä½“
    snake.clear();

    // åœ¨æ¸¸æˆç•Œé¢çš„ä¸­å¿ƒç”Ÿæˆè›‡å¤´
    int x = WIDTH / 2;
    int y = HEIGHT / 2;
    snake.add(new Point(x, y));

    // ç”Ÿæˆé£Ÿç‰©
    generateFood();

    // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
    gameOver = false;
    gamePaused = false;
}
```

#### æ­¥éª¤3ï¼šè›‡çš„ç§»åŠ¨

åœ¨æ¸¸æˆä¸­ï¼Œè›‡å¯ä»¥é€šè¿‡é”®ç›˜ä¸Šçš„ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘é”®æ¥æ§åˆ¶ç§»åŠ¨æ–¹å‘ã€‚æˆ‘ä»¬å¯ä»¥åœ¨`Scene`çš„æŒ‰é”®ç›‘å¬äº‹ä»¶ä¸­å®ç°ï¼Œæ ¹æ®æŒ‰ä¸‹çš„æ–¹å‘é”®ä¿®æ”¹è›‡çš„ç§»åŠ¨æ–¹å‘ã€‚å…·ä½“ä»£ç å®ç°å¦‚ä¸‹ï¼š

```java
// Sceneçš„æŒ‰é”®ç›‘å¬äº‹ä»¶
scene.setOnKeyPressed(event -> {
    KeyCode keyCode = event.getCode();
    switch (keyCode) {
        case UP:
            if (direction != Direction.DOWN) {
                direction = Direction.UP;
            }
            break;
        case DOWN:
            if (direction != Direction.UP) {
                direction = Direction.DOWN;
            }
            break;
        case LEFT:
            if (direction != Direction.RIGHT) {
                direction = Direction.LEFT;
            }
            break;
        case RIGHT:
            if (direction != Direction.LEFT) {
                direction = Direction.RIGHT;
            }
            break;
        case P:
            gamePaused = !gamePaused;
            break;
        case R:
            initGame();
            break;
        default:
            break;
    }
});
```

åœ¨æ¯æ¬¡åŠ¨ç”»å¾ªç¯ä¸­ï¼Œæ ¹æ®è›‡çš„ç§»åŠ¨æ–¹å‘æ¥è®¡ç®—ç§»åŠ¨åçš„æ–°ä½ç½®ã€‚å¦‚æœæ–°ä½ç½®åœ¨è›‡çš„èº«ä½“ä¸Šæˆ–è€…è¶…å‡ºäº†è¾¹ç•Œï¼Œå°±è¯´æ˜æ¸¸æˆç»“æŸäº†ã€‚åˆ¤æ–­è›‡æ˜¯å¦åƒåˆ°äº†é£Ÿç‰©ï¼Œå¦‚æœåƒåˆ°äº†å°±è®©è›‡çš„èº«ä½“å˜é•¿ï¼Œå¹¶åœ¨æ–°ä½ç½®ç”Ÿæˆä¸€ä¸ªæ–°çš„é£Ÿç‰©ã€‚

```java
// è›‡çš„ç§»åŠ¨æ–¹æ³•
private void move() {
    Point head = snake.getFirst();
    Point newHead = null;
    switch (direction) {
        case UP:
            newHead = new Point(head.getX(), head.getY() - 1);
            break;
        case DOWN:
            newHead = new Point(head.getX(), head.getY() + 1);
            break;
        case LEFT:
            newHead = new Point(head.getX() - 1, head.getY());
            break;
        case RIGHT:
            newHead = new Point(head.getX() + 1, head.getY());
            break;
        default:
            break;
    }

    // åˆ¤æ–­æ˜¯å¦æ’åˆ°è‡ªå·±çš„èº«ä½“
    if (snake.contains(newHead)) {
        gameOver = true;
        showGameOverDialog();
        return;
    }

    // åˆ¤æ–­æ˜¯å¦æ’åˆ°å¢™å£
    if (newHead.getX() < 0 || newHead.getX() >= WIDTH ||
            newHead.getY() < 0 || newHead.getY() >= HEIGHT) {
        gameOver = true;
        showGameOverDialog();
        return;
    }

    // æ›´æ–°è›‡çš„ä½ç½®
    snake.addFirst(newHead);

    // åˆ¤æ–­æ˜¯å¦åƒåˆ°äº†é£Ÿç‰©
    if (newHead.equals(food)) {
        // å¦‚æœåƒåˆ°äº†é£Ÿç‰©ï¼Œå°±è®©è›‡çš„èº«ä½“å˜é•¿
        generateFood();
    } else {
        // å¦‚æœæ²¡æœ‰åƒåˆ°é£Ÿç‰©ï¼Œå°±è®©è›‡çš„å°¾å·´æ¶ˆå¤±
        snake.removeLast();
    }
}
```

#### æ­¥éª¤4ï¼šæ£€æµ‹ç¢°æ’

åœ¨æ¯æ¬¡è›‡çš„ç§»åŠ¨åï¼Œéœ€è¦æ£€æµ‹è›‡æ˜¯å¦æ’åˆ°äº†è‡ªå·±çš„èº«ä½“ã€‚å¦‚æœæ’åˆ°äº†ï¼Œè¯´æ˜æ¸¸æˆç»“æŸäº†ã€‚å…·ä½“ä»£ç å®ç°å¦‚ä¸‹ï¼š

```java
// æ£€æµ‹ç¢°æ’æ–¹æ³•
private void checkCollision() {
    Point head = snake.getFirst();
    for (Point point : snake) {
        if (point != head && point.equals(head)) {
            gameOver = true;
            showGameOverDialog();
            break;
        }
    }
}
```

#### æ­¥éª¤5ï¼šç”Ÿæˆé£Ÿç‰©

æ¯ä¸ªé£Ÿç‰©éƒ½æ˜¯åœ¨æ¸¸æˆç•Œé¢ä¸Šéšæœºå‡ºç°çš„ï¼Œé£Ÿç‰©ä¸èƒ½å‡ºç°åœ¨è›‡çš„èº«ä½“ä¸Šã€‚ç”Ÿæˆé£Ÿç‰©æ—¶ï¼Œå¯ä»¥ä½¿ç”¨`do-while`å¾ªç¯æ¥åˆ¤æ–­æ˜¯å¦æœ‰é‡åˆçš„æƒ…å†µã€‚å…·ä½“ä»£ç å®ç°å¦‚ä¸‹ï¼š

```java
// ç”Ÿæˆé£Ÿç‰©æ–¹æ³•
private void generateFood() {
    boolean validPosition;
    int x, y;
    do {
        validPosition = true;
        x = (int) (Math.random() * WIDTH);
        y = (int) (Math.random() * HEIGHT);
        for (Point point : snake) {
            if (point.getX() == x && point.getY() == y) {
                validPosition = false;
                break;
            }
        }
    } while (!validPosition);
    food = new Point(x, y);
}
```

#### æ­¥éª¤6ï¼šç»˜åˆ¶æ¸¸æˆç”»é¢

åœ¨`Canvas`ä¸Šé€šè¿‡`GraphicsContext`ç»˜åˆ¶è›‡ã€é£Ÿç‰©ç­‰æ¸¸æˆå…ƒç´ ï¼Œå®ç°æ¸¸æˆçš„ç”»é¢ã€‚å…·ä½“ä»£ç å®ç°å¦‚ä¸‹ï¼š

```java
// ç»˜åˆ¶æ¸¸æˆç”»é¢æ–¹æ³•
private void paint(GraphicsContext gc) {
    // æ¸…ç©ºç”»å¸ƒ
    gc.clearRect(0, 0, WIDTH * SIZE, HEIGHT * SIZE);

    // ç»˜åˆ¶è›‡èº«
    gc.setFill(javafx.scene.paint.Color.GREEN);
    for (Point point : snake) {
        gc.fillRect(point.getX() * SIZE, point.getY() * SIZE, SIZE, SIZE);
    }

    // ç»˜åˆ¶å¤´éƒ¨
    gc.setFill(javafx.scene.paint.Color.DARKGREEN);
    Point head = snake.getFirst();
    gc.fillRect(head.getX() * SIZE, head.getY() * SIZE, SIZE, SIZE);

    // ç»˜åˆ¶é£Ÿç‰©
    gc.setFill(javafx.scene.paint.Color.RED);
    gc.fillRect(food.getX() * SIZE, food.getY() * SIZE, SIZE, SIZE);
}
```

#### æ­¥éª¤7ï¼šæ˜¾ç¤ºæ¸¸æˆç»“æŸå¯¹è¯æ¡†

å½“æ¸¸æˆç»“æŸæ—¶ï¼Œå¼¹å‡ºå¾—åˆ†å¯¹è¯æ¡†ï¼Œç‚¹å‡»é‡æ–°å¼€å§‹æ–°æ¸¸æˆã€‚å…·ä½“ä»£ç å®ç°å¦‚ä¸‹ï¼š

```java
// æ˜¾ç¤ºæ¸¸æˆç»“æŸå¯¹è¯æ¡†æ–¹æ³•
private void showGameOverDialog() {
    Alert alert = new Alert(AlertType.INFORMATION);
    alert.setTitle("æ¸¸æˆç»“æŸ");
    alert.setHeaderText(null);
    alert.setContentText("æ¸¸æˆç»“æŸï¼Œæ‚¨çš„å¾—åˆ†æ˜¯ï¼š" + (snake.size() - 1));
    alert.show();

    alert.setOnHidden(event -> {
        initGame();
    });
}
```

è‡³æ­¤ï¼Œè´ªåƒè›‡æ¸¸æˆçš„å®ç°å·²ç»å®Œæˆäº†ã€‚

å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

```java
package org.example;

import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

import java.util.ArrayDeque;
import java.util.Deque;

public class SnakeGame extends Application {

    private static final int WIDTH = 20; // æ¸¸æˆç•Œé¢çš„å®½åº¦
    private static final int HEIGHT = 20; // æ¸¸æˆç•Œé¢çš„é«˜åº¦
    private static final int SIZE = 20; // æ¯ä¸ªæ ¼å­çš„å¤§å°
    private static final int SPEED = 5; // è›‡çš„é€Ÿåº¦

    private Deque<Point> snake = new ArrayDeque<>(); // è›‡çš„èº«ä½“
    private Direction direction = Direction.RIGHT; // è›‡çš„åˆå§‹æ–¹å‘

    private Point food; // é£Ÿç‰©çš„ä½ç½®

    private boolean gameOver = false; // æ¸¸æˆæ˜¯å¦ç»“æŸ
    private boolean gamePaused = false; // æ¸¸æˆæ˜¯å¦æš‚åœ

    @Override
    public void start(Stage primaryStage) throws Exception {
        Canvas canvas = new Canvas(WIDTH * SIZE, HEIGHT * SIZE);
        GraphicsContext gc = canvas.getGraphicsContext2D();
        StackPane root = new StackPane(canvas);
        root.setAlignment(Pos.CENTER);

        Scene scene = new Scene(root);
        scene.setOnKeyPressed(event -> {
            KeyCode keyCode = event.getCode();
            switch (keyCode) {
                case UP:
                    if (direction != Direction.DOWN) {
                        direction = Direction.UP;
                    }
                    break;
                case DOWN:
                    if (direction != Direction.UP) {
                        direction = Direction.DOWN;
                    }
                    break;
                case LEFT:
                    if (direction != Direction.RIGHT) {
                        direction = Direction.LEFT;
                    }
                    break;
                case RIGHT:
                    if (direction != Direction.LEFT) {
                        direction = Direction.RIGHT;
                    }
                    break;
                case P:
                    gamePaused = !gamePaused;
                    break;
                case R:
                    initGame();
                    break;
                default:
                    break;
            }
        });

        primaryStage.setScene(scene);
        primaryStage.setTitle("è´ªåƒè›‡æ¸¸æˆ");
        primaryStage.setResizable(false);
        primaryStage.show();

        initGame();

        new AnimationTimer() {
            private long lastUpdateTime;

            @Override
            public void handle(long now) {
                if (now - lastUpdateTime >= 1_000_000_000 / SPEED) { // è°ƒæ•´è›‡çš„é€Ÿåº¦
                    lastUpdateTime = now;
                    if (!gameOver && !gamePaused) {
                        move();
                        checkCollision();
                        paint(gc);
                    }
                }
            }
        }.start();
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    private void initGame() {
        snake.clear();
        snake.add(new Point(WIDTH / 2, HEIGHT / 2));
        generateFood();
        gameOver = false;
        gamePaused = false;
    }

    // è›‡çš„ç§»åŠ¨
    private void move() {
        Point head = snake.getFirst();
        Point newHead = null;
        switch (direction) {
            case UP:
                newHead = new Point(head.getX(), head.getY() - 1);
                break;
            case DOWN:
                newHead = new Point(head.getX(), head.getY() + 1);
                break;
            case LEFT:
                newHead = new Point(head.getX() - 1, head.getY());
                break;
            case RIGHT:
                newHead = new Point(head.getX() + 1, head.getY());
                break;
            default:
                break;
        }
        // åˆ¤æ–­æ˜¯å¦æ’åˆ°è‡ªå·±çš„èº«ä½“
        if (snake.contains(newHead)) {
            gameOver = true;
            showGameOverDialog();
            return;
        }
        // åˆ¤æ–­æ˜¯å¦æ’åˆ°å¢™å£
        if (newHead.getX() < 0 || newHead.getX() >= WIDTH ||
                newHead.getY() < 0 || newHead.getY() >= HEIGHT) {
            gameOver = true;
            showGameOverDialog();
            return;
        }
        snake.addFirst(newHead);
        if (newHead.equals(food)) {
            generateFood();
        } else {
            snake.removeLast();
        }
    }

    // æ£€æµ‹ç¢°æ’
    private void checkCollision() {
        Point head = snake.getFirst();
        for (Point point : snake) {
            if (point != head && point.equals(head)) {
                gameOver = true;
                showGameOverDialog();
                break;
            }
        }
    }

    // ç”Ÿæˆé£Ÿç‰©
    private void generateFood() {
        boolean validPosition;
        int x, y;
        do {
            validPosition = true;
            x = (int) (Math.random() * WIDTH);
            y = (int) (Math.random() * HEIGHT);
            for (Point point : snake) {
                if (point.getX() == x && point.getY() == y) {
                    validPosition = false;
                    break;
                }
            }
        } while (!validPosition);
        food = new Point(x, y);
    }

    // ç»˜åˆ¶æ¸¸æˆç”»é¢
    private void paint(GraphicsContext gc) {
        // æ¸…ç©ºç”»å¸ƒ
        gc.clearRect(0, 0, WIDTH * SIZE, HEIGHT * SIZE);

        // ç»˜åˆ¶è›‡èº«
        gc.setFill(javafx.scene.paint.Color.GREEN);
        for (Point point : snake) {
            gc.fillRect(point.getX() * SIZE, point.getY() * SIZE, SIZE, SIZE);
        }

        // ç»˜åˆ¶å¤´éƒ¨
        gc.setFill(javafx.scene.paint.Color.DARKGREEN);
        Point head = snake.getFirst();
        gc.fillRect(head.getX() * SIZE, head.getY() * SIZE, SIZE, SIZE);

        // ç»˜åˆ¶é£Ÿç‰©
        gc.setFill(javafx.scene.paint.Color.RED);
        gc.fillRect(food.getX() * SIZE, food.getY() * SIZE, SIZE, SIZE);
    }

    // æ˜¾ç¤ºæ¸¸æˆç»“æŸå¯¹è¯æ¡†
    private void showGameOverDialog() {
        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("æ¸¸æˆç»“æŸ");
        alert.setHeaderText(null);
        alert.setContentText("æ¸¸æˆç»“æŸï¼Œæ‚¨çš„å¾—åˆ†æ˜¯ï¼š" + (snake.size() - 1));
        alert.show();

        alert.setOnHidden(event -> {
            initGame(); // æ¸¸æˆç»“æŸåé‡æ–°å¼€å§‹æ¸¸æˆ
        });
    }

    // æ–¹å‘æšä¸¾ç±»
    private enum Direction {
        UP, DOWN, LEFT, RIGHT
    }

    // åæ ‡ç‚¹ç±»
    private static class Point {
        private int x;
        private int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Point point = (Point) o;
            return x == point.x && y == point.y;
        }

        @Override
        public int hashCode() {
            return x * 31 + y;
        }
    }

    public static void main(String[] args) {
        launch(args);
    }

}
```

![](https://files.mdnice.com/user/33663/cbff779f-c976-4135-9b93-ba208a5b0624.png)

å…³æ³¨å¾®ä¿¡å…¬ä¼—å·ï¼šâ€œå°è™å“¥çš„æŠ€æœ¯åšå®¢â€ã€‚æˆ‘ä»¬ä¼šå®šæœŸå‘å¸ƒå…³äºJavaæŠ€æœ¯çš„è¯¦å°½æ–‡ç« ï¼Œè®©æ‚¨èƒ½å¤Ÿæ·±å…¥äº†è§£è¯¥é¢†åŸŸçš„å„ç§æŠ€å·§å’Œæ–¹æ³•ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æˆä¸ºæ›´ä¼˜ç§€çš„ç¨‹åºå‘˜ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»ï¼

ç›¸å…³æ–‡ç« æºç æ”¾åœ¨ï¼š[giteeä»“åº“](https://gitee.com/cunzaizhe/xiaohuge-blog)ã€[githubä»“åº“](https://github.com/tigerleeli/xiaohuge-blog)ä¸Šã€‚

